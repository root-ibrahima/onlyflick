import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import './auth_service.dart';
import 'models/auth_models.dart';
import '../../core/services/api_service.dart';

class AuthProvider extends ChangeNotifier {
  final AuthService _authService = AuthService();
  final ApiService _apiService = ApiService();

  // √âtat d'authentification
  AuthState _state = AuthState.initial;
  User? _user;
  AuthError? _error;

  // Getters
  AuthState get state => _state;
  User? get user => _user;
  AuthError? get error => _error;
  
  bool get isLoading => _state == AuthState.loading;
  bool get isAuthenticated => _state == AuthState.authenticated && _user != null;
  bool get isUnauthenticated => _state == AuthState.unauthenticated;
  bool get hasError => _state == AuthState.error && _error != null;

  // Getters de r√¥le
  bool get isCreator => _user?.isCreator ?? false;
  bool get isAdmin => _user?.isAdmin ?? false;
  bool get isSubscriber => _user?.isSubscriber ?? false;

  /// Initialise le provider et v√©rifie l'√©tat d'authentification
  Future<void> checkAuth() async {
    debugPrint('üîê Checking authentication state...');
    
    try {
      // Initialiser l'API service
      await _apiService.initialize();
      
      // V√©rifier si un token existe et est valide
      if (_authService.hasToken()) {
        _setState(AuthState.loading);
        
        final result = await _authService.getProfile();
        if (result.isSuccess && result.data != null) {
          _user = result.data;
          _setState(AuthState.authenticated);
          debugPrint('üîê User authenticated: ${_user!.email}');
        } else {
          _setState(AuthState.unauthenticated);
          debugPrint('üîê Token invalid, user unauthenticated');
        }
      } else {
        _setState(AuthState.unauthenticated);
        debugPrint('üîê No token found, user unauthenticated');
      }
    } catch (e) {
      debugPrint('‚ùå Auth check error: $e');
      _setState(AuthState.unauthenticated);
    }
  }

  /// Connexion utilisateur
  Future<bool> login(String email, String password) async {
    debugPrint('üîê Login attempt for: $email');
    
    _setState(AuthState.loading);
    _clearError();

    try {
      final request = LoginRequest(email: email, password: password);
      final result = await _authService.login(request);

      if (result.isSuccess) {
        // R√©cup√©rer le profil utilisateur
        final profileResult = await _authService.getProfile();
        
        if (profileResult.isSuccess && profileResult.data != null) {
          _user = profileResult.data;
          _setState(AuthState.authenticated);
          debugPrint('üîê Login successful for: ${_user!.email}');
          return true;
        } else {
          _setError(profileResult.error ?? AuthError.server());
          return false;
        }
      } else {
        _setError(result.error ?? AuthError.server());
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå Login error: $e');
      _setError(AuthError.network());
      return false;
    }
  }

  /// Inscription utilisateur
  Future<bool> register(String firstName, String lastName, String email, String password) async {
    debugPrint('üîê Registration attempt for: $email');
    
    _setState(AuthState.loading);
    _clearError();

    try {
      final request = RegisterRequest(
        firstName: firstName,
        lastName: lastName,
        email: email,
        password: password,
      );
      
      final result = await _authService.register(request);

      if (result.isSuccess) {
        // R√©cup√©rer le profil utilisateur
        final profileResult = await _authService.getProfile();
        
        if (profileResult.isSuccess && profileResult.data != null) {
          _user = profileResult.data;
          _setState(AuthState.authenticated);
          debugPrint('üîê Registration successful for: ${_user!.email}');
          return true;
        } else {
          _setError(profileResult.error ?? AuthError.server());
          return false;
        }
      } else {
        _setError(result.error ?? AuthError.server());
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå Registration error: $e');
      _setError(AuthError.network());
      return false;
    }
  }

  /// Mise √† jour du profil utilisateur
  Future<bool> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? password,
  }) async {
    if (!isAuthenticated) return false;
    
    debugPrint('üîê Updating profile for: ${_user!.email}');
    
    _setState(AuthState.loading);
    _clearError();

    try {
      final request = UpdateProfileRequest(
        firstName: firstName,
        lastName: lastName,
        email: email,
        password: password,
      );
      
      final result = await _authService.updateProfile(request);

      if (result.isSuccess && result.data != null) {
        _user = result.data;
        _setState(AuthState.authenticated);
        debugPrint('üîê Profile updated successfully');
        return true;
      } else {
        _setError(result.error ?? AuthError.server());
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå Profile update error: $e');
      _setError(AuthError.network());
      return false;
    }
  }

  /// Demande de passage en cr√©ateur
  Future<bool> requestCreatorUpgrade() async {
    if (!isAuthenticated) return false;
    
    debugPrint('üîê Requesting creator upgrade for: ${_user!.email}');
    
    _setState(AuthState.loading);
    _clearError();

    try {
      final result = await _authService.requestCreatorUpgrade();

      if (result.isSuccess) {
        // Recharger le profil pour voir si le statut a chang√©
        await _refreshProfile();
        debugPrint('üîê Creator upgrade request sent successfully');
        return true;
      } else {
        _setError(result.error ?? AuthError.server());
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå Creator upgrade request error: $e');
      _setError(AuthError.network());
      return false;
    }
  }

  /// Suppression du compte
  Future<bool> deleteAccount() async {
    if (!isAuthenticated) return false;
    
    debugPrint('üîê Deleting account for: ${_user!.email}');
    
    _setState(AuthState.loading);
    _clearError();

    try {
      final result = await _authService.deleteAccount();

      if (result.isSuccess) {
        _user = null;
        _setState(AuthState.unauthenticated);
        debugPrint('üîê Account deleted successfully');
        return true;
      } else {
        _setError(result.error ?? AuthError.server());
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå Account deletion error: $e');
      _setError(AuthError.network());
      return false;
    }
  }

  /// D√©connexion utilisateur
  Future<void> logout() async {
    debugPrint('üîê Logging out user: ${_user?.email}');
    
    await _authService.logout();
    _user = null;
    _setState(AuthState.unauthenticated);
    _clearError();
    
    debugPrint('üîê User logged out successfully');
  }

  /// Actualise le profil utilisateur
  Future<void> refreshProfile() async {
    await _refreshProfile();
  }

  /// Actualise le profil utilisateur (m√©thode priv√©e)
  Future<void> _refreshProfile() async {
    if (!isAuthenticated) return;
    
    try {
      final result = await _authService.getProfile();
      
      if (result.isSuccess && result.data != null) {
        _user = result.data;
        _setState(AuthState.authenticated);
      } else if (result.error?.isAuthError ?? false) {
        // Si erreur d'auth, d√©connecter
        await logout();
      }
    } catch (e) {
      debugPrint('‚ùå Profile refresh error: $e');
    }
  }

  /// Change l'√©tat et notifie les listeners
  void _setState(AuthState newState) {
    if (_state != newState) {
      _state = newState;
      notifyListeners();
    }
  }

  /// D√©finit une erreur et change l'√©tat
  void _setError(AuthError authError) {
    _error = authError;
    _setState(AuthState.error);
  }

  /// Efface l'erreur
  void _clearError() {
    _error = null;
  }

  /// M√©thode pour v√©rifier si l'utilisateur est connect√© (legacy)
  Future<bool> isLoggedIn() async {
    return isAuthenticated;
  }

  /// M√©thode pour d√©finir l'√©tat connect√© (legacy)
  Future<void> setLoggedIn(bool value) async {
    if (value && !isAuthenticated) {
      await checkAuth();
    } else if (!value && isAuthenticated) {
      await logout();
    }
  }

  @override
  void dispose() {
    super.dispose();
  }
}